= TP : Infrastructure & API avec Node.js (Mini-Nagios)
:author: Timoth√©e Robert & Les IA
:revdate: 2026-02-01
:toc: left
:toc-title: Sommaire
:icons: font
:source-highlighter: highlightjs
:sectnums:

== Introduction : Du PHP √† Node.js

Jusqu'√† pr√©sent, nous avons cod√© en PHP (mod√®le synchrone, orient√© "page web").
Aujourd'hui, nous basculons sur **Node.js** (JavaScript c√¥t√© serveur).

Pourquoi ce changement pour un profil DevOps/SISR ?

* **Coco**: demande de r√©vision autour de JS
* **API First :** Node.js est roi pour cr√©er des API JSON rapides.
* **Asynchrone :** Il g√®re tr√®s bien de nombreuses connexions simultan√©es (monitoring).
* **Isomorphisme :** Le m√™me langage (JS) pour le script serveur, le script client et les outils de build.

=== Pr√©requis Techniques

.   Ouvrez un terminal.
.   Initialisez le projet : git clone ou git pull si vous avez d√©j√† le repo


---

== S√âANCE 1 : POO Moderne, H√©ritage & Composition

=== La POO en JavaScript (ES6)

Oubliez les `function` √† l'ancienne. Depuis 2015 (ES6), JS poss√®de une syntaxe `class` tr√®s proche de PHP ou Java.

==== Classe M√®re & Composition
*Concept cl√© : La Composition.*
Au lieu de dire "Un Serveur a une IP (texte)", nous dirons "Un Serveur **a une** Carte R√©seau (Objet)".
C'est la relation **Has-A** (A un).

Cr√©ez le fichier `src/CarteReseau.js` :
[source,javascript]
----
export class CarteReseau {
    constructor(ip, mac) {
        this.ip = ip;
        this.mac = mac;
        this.isConnected = false;
    }

    plug() {
        this.isConnected = true;
    }

    unplug() {
        this.isConnected = false;
    }

    toString() {
        return `IP: ${this.ip} (MAC: ${this.mac}) - ${this.isConnected ? 'üü¢' : 'üî¥'}`;
    }
}
----

Cr√©ez le fichier `src/Equipement.js` :
[source,javascript]
----
// On importe la d√©pendance
import { CarteReseau } from './CarteReseau.js';

export class Equipement {
    // En JS, les propri√©t√©s peuvent √™tre d√©clar√©es ici (champs publics) ou directement dans le constructeur
    // Le '#' devant un nom de variable le rend PRIVE (Encapsulation stricte)
    #hostname;

    constructor(hostname, ip, mac) {
        this.#hostname = hostname;

        // COMPOSITION : L'√©quipement instancie sa propre carte r√©seau
        this.carte = new CarteReseau(ip, mac);

        // Par d√©faut, on branche le c√¢ble
        this.carte.plug();
    }

    getHostname() {
        return this.#hostname;
    }

    // M√©thode standard
    afficherStatut() {
        return `Machine : ${this.#hostname} | ${this.carte.toString()}`;
    }
}
----

=== H√©ritage et "Surcharge" (Overriding)

*Question fr√©quente :* Y a-t-il de la surcharge en JS ?

* **Red√©finition (Overriding) :** OUI. L'enfant r√©√©crit une m√©thode du parent. On utilise `super.methode()` pour garder le comportement parent.
* **Surcharge (Overloading) :** NON (pas nativement). On ne peut pas avoir `afficher(a)` et `afficher(a, b)`.
* *Solution JS :* On utilise des param√®tres par d√©faut ou on v√©rifie le type des arguments dans une seule m√©thode.

Cr√©ez `src/Serveur.js` :
[source,javascript]
----
import { Equipement } from './Equipement.js';

export class Serveur extends Equipement {
    constructor(hostname, ip, mac, os) {
        // Appel obligatoire au constructeur parent
        super(hostname, ip, mac);
        this.os = os;
    }

    // RED√âFINITION (Overriding)
    afficherStatut() {
        // On enrichit l'affichage du parent
        return `${super.afficherStatut()} | OS : ${this.os}`;
    }
}
----

== Exercices Pratiques (Partie 1)

=== Exercice 1 : Le Routeur (H√©ritage)
Cr√©ez la classe `src/Routeur.js`.

* Elle h√©rite de `Equipement`.
* Elle poss√®de un attribut `nbPorts` (int).
* Red√©finissez `afficherStatut()` pour inclure le nombre de ports.

=== Exercice 2 : La Baie de Brassage (Composition Avanc√©e)
Une baie (Rack) contient plusieurs √©quipements.
Cr√©ez la classe `src/Baie.js`.

* Attribut : `equipements` (Un tableau vide `[]` au d√©part).
* M√©thode : `ajouterEquipement(eq)` qui pousse l'objet dans le tableau.
* M√©thode : `toutAllumer()` qui parcourt le tableau et appelle `plug()` sur la carte r√©seau de chaque machine.
* M√©thode : `listerContenu()` qui retourne un tableau de cha√Ænes (les statuts).

=== Exercice 3 : Script de test
Cr√©ez un fichier `index.js` √† la racine pour tester votre logique.
[source,javascript]
----
import { Serveur } from './src/Serveur.js';
import { Routeur } from './src/Routeur.js';
import { Baie } from './src/Baie.js';

const srv1 = new Serveur("Web-01", "192.168.1.10", "AA:BB:CC:00:11", "Debian");
const rtr1 = new Routeur("Core-SW", "192.168.1.1", "AA:BB:CC:DD:EE", 24);

console.log(srv1.afficherStatut());

// Test de la baie... √† vous de jouer !
----
Lancez avec `node index.js`.

---

== S√âANCE 2 : Tests Unitaires, Robustesse & API REST

Nos classes fonctionnent, mais sont-elles solides ? Et comment les rendre accessibles aux autres applications ?

=== Tests Unitaires avec Jest

En JS, le standard de test est **Jest**.
Installez-le (en mode d√©veloppement uniquement) :
[source,bash]
----
npm install --save-dev jest
----

Modifiez `package.json` pour changer la commande de test :
[source,json]
----
"scripts": {
    "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js"
}
----
*(L'option experimental-vm-modules est n√©cessaire car nous utilisons "type": "module")*

=== Cr√©ation d'un Validator (M√©thodes Statiques)
Cr√©ez `src/Validator.js`. C'est notre bo√Æte √† outils.

[source,javascript]
----
export class Validator {
    /**
     * Valide une IP (Regex simplifi√©e pour l'exemple)
     * @param {string} ip
     * @returns {boolean}
     */
    static isIpValid(ip) {
        const regex = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/;
        return regex.test(ip);
    }

    static isMacValid(mac) {
        // Format AA:BB:CC:DD:EE:FF
        const regex = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/;
        return regex.test(mac);
    }
}
----

=== √âcriture du Test
Cr√©ez le fichier `tests/Validator.test.js`. Jest cherche automatiquement les fichiers `.test.js`.

[source,javascript]
----
import { Validator } from '../src/Validator.js';

describe('Tests du Validator', () => {

    test('Une IP correcte doit retourner true', () => {
        expect(Validator.isIpValid('192.168.1.1')).toBe(true);
    });

    test('Une IP incorrecte (texte) doit retourner false', () => {
        expect(Validator.isIpValid('patate')).toBe(false);
    });

    test('Une IP incorrecte (trop longue) doit retourner false', () => {
        expect(Validator.isIpValid('999.999.999.9999')).toBe(false); // Regex simplifi√©e accepte 999, am√©liorez la regex en exercice !
    });
});
----

Lancez les tests : `npm test`.

== Cr√©ation de l'API avec Express

Nous allons transformer notre script console en serveur Web.
Installez Express : `npm install express`

Cr√©ez le fichier `app.js` :
[source,javascript]
----
import express from 'express';
import { Serveur } from './src/Serveur.js';
import { Validator } from './src/Validator.js';

const app = express();
const port = 3000;

// Middleware pour comprendre le JSON envoy√© par les clients
app.use(express.json());

// Notre "Base de donn√©es" en m√©moire
const parcInformatique = [];

// ROUTE 1 : GET (Lecture)
app.get('/api/equipements', (req, res) => {
    // On transforme nos objets en un format JSON simple pour l'affichage
    const reponse = parcInformatique.map(eq => ({
        hostname: eq.getHostname(),
        details: eq.afficherStatut()
    }));
    res.json(reponse);
});

// ROUTE 2 : POST (Cr√©ation) avec Try/Catch
app.post('/api/serveurs', (req, res) => {
    try {
        const { hostname, ip, mac, os } = req.body;

        // Validation d√©fensive
        if (!Validator.isIpValid(ip)) {
            throw new Error(`L'IP ${ip} est invalide !`);
        }

        const nouveauSrv = new Serveur(hostname, ip, mac, os);
        parcInformatique.push(nouveauSrv);

        res.status(201).json({
            message: "Serveur cr√©√©",
            machine: nouveauSrv.afficherStatut()
        });

    } catch (error) {
        // En cas d'erreur, on renvoie une 400 (Bad Request)
        res.status(400).json({ error: error.message });
    }
});

app.listen(port, () => {
    console.log(`API Mini-Nagios √©coute sur http://localhost:${port}`);
});
----

== Exercices Pratiques (Partie 2)

=== Exercice 4 : Am√©lioration des Tests
Dans `tests/Validator.test.js`, ajoutez des tests pour la m√©thode `isMacValid`.

* Testez une MAC valide (`AA:BB:CC:DD:EE:FF`).
* Testez une MAC invalide (`ZZ:ZZ...`).
* Testez une cha√Æne vide.

=== Exercice 5 : Routeur API
Ajoutez une route POST `/api/routeurs` dans `app.js`.

* Elle doit accepter un JSON `{ hostname, ip, mac, nbPorts }`.
* Elle doit instancier un objet `Routeur`.
* Elle doit valider que `nbPorts` est bien un nombre entre 4 et 48. Sinon -> Erreur 400.

=== Exercice 6 : Recherche par ID (Param√®tres de route)
Ajoutez une route `GET /api/equipements/:index`.

* Si l'utilisateur appelle `/api/equipements/0`, renvoyez le premier √©l√©ment du tableau.
* Si l'index n'existe pas, renvoyez une erreur 404 (`res.status(404).json(...)`).

=== Exercice 7 : Simulation de panne (Patch)
Ajoutez une route `PATCH /api/equipements/:index/unplug`.

* Cette route doit r√©cup√©rer l'√©quipement √† l'index donn√©.
* Elle doit appeler la m√©thode `carte.unplug()` de l'√©quipement.
* Renvoyez le nouveau statut.

== Annexe : Comment tester l'API ?

Comme nous n'avons pas de formulaire HTML, utilisez un outil comme **Postman**, **Insomnia**, ou l'extension VS Code **Thunder Client**.

Exemple de requ√™te POST pour cr√©er un serveur :

* **Method:** POST
* **URL:** `http://localhost:3000/api/serveurs`
* **Header:** `Content-Type: application/json`
* **Body (JSON):**
```json
{
"hostname": "SRV-TEST",
"ip": "192.168.0.50",
"mac": "A1:B2:C3:D4:E5:F6",
"os": "Ubuntu"
}
```

Exemple avec Curl
```ascii
curl -X POST http://localhost:3000/api/serveurs ^
     -H "Content-Type: application/json" ^
     -d "{\"hostname\": \"SRV-TEST\", \"ip\": \"192.168.0.50\", \"mac\": \"A1:B2:C3:D4:E5:F6\", \"os\": \"Ubuntu\"}"
```

== Annexe: m√©thode de classe & m√©thode d'instance - le Concept Fondamental

En Programmation Orient√©e Objet, il existe deux mani√®res d'utiliser des fonctions et des variables. La distinction se fait sur la question : **"√Ä qui appartient cette fonctionnalit√© ?"**

[cols="1,2,2", options="header"]
|===
| Crit√®re | M√©thode d'Instance (Standard) | M√©thode de Classe (Statique)

| **C'est quoi ?**
| Une action li√©e √† un **objet unique**. Elle a besoin des donn√©es sp√©cifiques de l'objet (son nom, son IP, son solde...).
| Une action li√©e √† la **Classe** (le moule). C'est un outil ou un service global qui n'a pas besoin de donn√©es sp√©cifiques.

| **L'Analogie**
| **La Voiture :** `accelerer()`. +
Pour acc√©l√©rer, je dois √™tre assis dans une voiture pr√©cise. La Ferrari acc√©l√®re plus vite que la Twingo.
| **L'Usine :** `construireVoiture()`. +
L'usine n'a pas besoin d'√™tre "d√©marr√©e" comme une voiture. Elle offre un service de fabrication.

| **Acc√®s aux donn√©es**
| ‚úÖ A acc√®s √† `$this` (PHP) ou `this` (Java/JS).
| ‚ùå **INTERDIT** d'utiliser `this`. La m√©thode ne connait aucun objet particulier.
|===

=== Repr√©sentation Visuelle

[mermaid]
....
classDiagram
    class CompteBancaire {
        -solde : float
        -titulaire : string
        +retirerArgent(montant)
        +afficherSolde()
        ___
        +static tauxInteret : float
        +static changerTauxNational(nouveauTaux)
    }

    note for CompteBancaire "Partie Instance (Haut) :
Sp√©cifique √† M. Dupont ou Mme Martin"
    note for CompteBancaire "Partie Statique (Bas) :
Commun √† TOUS les comptes de la banque"
....

== Comparatif Syntaxique (La "Cheat Sheet")

Voici comment d√©clarer et utiliser ces concepts dans les trois langages majeurs du BTS SIO.

=== D√©claration dans la Classe

Observez le mot-cl√© **`static`** qui revient partout.

[tabs]
====
PHP::
+
[source,php]
----
class Utilisateur {
    // Variable de Classe (Partag√©e par tous)
    public static $compteur = 0;

    // M√©thode de Classe (Utilitaire)
    public static function getInfo() {
        return "Syst√®me v1.0";
    }

    // M√©thode d'Instance (Classique)
    public function seConnecter() {
        // ...
    }
}
----

Java::
+
[source,java]
----
public class Utilisateur {
    // Variable de Classe
    public static int compteur = 0;

    // M√©thode de Classe
    public static String getInfo() {
        return "Syst√®me v1.0";
    }

    // M√©thode d'Instance
    public void seConnecter() {
        // ...
    }
}
----

JavaScript (ES6)::
+
[source,javascript]
----
class Utilisateur {
    // Variable de Classe (Moderne : static fields)
    static compteur = 0;

    // M√©thode de Classe
    static getInfo() {
        return "Syst√®me v1.0";
    }

    // M√©thode d'Instance
    seConnecter() {
        // ...
    }
}
----
====

=== Utilisation (Appel)

C'est ici que les diff√©rences de syntaxe sont les plus marqu√©es, notamment avec le **Paamayim Nekudotayim** (`::`) de PHP.

[cols="1,3,3,3", options="header"]
|===
| Action | PHP | Java | JavaScript

| **Appeler du Statique**
(Depuis l'ext√©rieur)
| `Utilisateur::getInfo()`
| `Utilisateur.getInfo()`
| `Utilisateur.getInfo()`

| **Appeler du Statique**
(Depuis l'int√©rieur de la classe)
| `self::getInfo()`
| `Utilisateur.getInfo()`
ou simplement `getInfo()`
| `Utilisateur.getInfo()`
ou `this.constructor.getInfo()`

| **Appeler de l'Instance**
(Depuis l'ext√©rieur)
| `$u = new Utilisateur();`
`$u->seConnecter();`
| `Utilisateur u = new Utilisateur();`
`u.seConnecter();`
| `const u = new Utilisateur();`
`u.seConnecter();`

| **Acc√®s propri√©t√© Statique**
| `Utilisateur::$compteur`
| `Utilisateur.compteur`
| `Utilisateur.compteur`
|===

== Quand utiliser quoi ? (Best Practices)

Lors de vos projets ou examens, posez-vous ces questions pour choisir :

. **Est-ce que la m√©thode a besoin de donn√©es stock√©es dans l'objet (ex: `$this->nom`) ?**
* OUI -> C'est une **M√©thode d'Instance**.
* NON -> C'est probablement une **M√©thode Statique**.

. **Est-ce que c'est une fonction utilitaire (Math, Validation, Formatage) ?**
* OUI -> **Statique**. Ex: `Validator::isEmailValid($email)`.

. **Est-ce que c'est un compteur global ou une configuration partag√©e ?**
* OUI -> **Attribut Statique**. Ex: `Compteur::$nombreVisiteurs`.

[IMPORTANT]
.Le Pi√®ge Classique
====
En PHP, n'essayez jamais d'utiliser `$this` dans une m√©thode statique.
Cela provoquera une erreur fatale imm√©diate : _"Using $this when not in object context"_.
====

== Exercice de Synth√®se (Multi-langages)

**Sc√©nario :** Cr√©er une classe `MathHelper` qui permet de calculer le carr√© d'un nombre sans instancier la classe.

.Version PHP
[source,php]
----
class MathHelper {
    public static function carre(float $n): float {
        return $n * $n;
    }
}
// Utilisation
echo MathHelper::carre(5); // Affiche 25
----

.Version JavaScript
[source,javascript]
----
class MathHelper {
    static carre(n) {
        return n * n;
    }
}
// Utilisation
console.log(MathHelper.carre(5)); // Affiche 25
----

== S√âANCE 3 : Architecture Complexe & Consolidation

Lors de la S√©ance 1, nous avons mod√©lis√© des objets, puis nous avons produit et utilis√© une API s√©curis√©e en S√©ance 2.
Nous allons maintenant relier le tout pour cr√©er une v√©ritable application de gestion de Datacenter.

**Les d√©fis du jour :**

* **√âvolution de la Composition :** Nous allons rendre notre classe `Baie` plus intelligente en lui ajoutant une limite physique.
* **TDD (Test Driven Development) :** Nous allons √©crire le test qui valide la capacit√© **avant** de modifier le code.
* **API Imbriqu√©e :** G√©rer des √©quipements *dans* des baies via HTTP.

== TDD : Tester les limites de la Baie

Avant de toucher au code de `Baie.js`, nous allons d√©finir son comportement attendu via un test.
Une baie doit avoir une capacit√© maximale. Si on essaie d'ajouter un √©quipement alors qu'elle est pleine, elle doit refuser l'ajout.

=== Exercice 1 : Le Test de Capacit√©
Cr√©ez le fichier `tests/Baie.test.js`. Recopiez le code ci-dessous.
Ce code d√©finit le comportement attendu (la "Sp√©cification").

[source,javascript]
----
import { Baie } from '../src/Baie.js';
import { Serveur } from '../src/Serveur.js';

describe('Logique M√©tier : Baie de Brassage', () => {

    test('On peut ajouter un √©quipement s\'il y a de la place', () => {
        // On initialise une baie avec une capacit√© de 10
        const rack = new Baie("TestRack", 10);
        const srv = new Serveur("Srv1", "1.1.1.1", "AA:BB:CC:00:00:01", "Linux");

        rack.ajouterEquipement(srv);

        // Assertion : Le tableau doit contenir 1 √©l√©ment
        expect(rack.equipements.length).toBe(1);
    });

    test('La baie doit refuser l\'ajout si elle est pleine', () => {
        // 1. Pr√©paration : Une baie minuscule (Capacit√© 1)
        const rack = new Baie("TinyRack", 1);
        const srv1 = new Serveur("Srv1", "1.1.1.1", "AA:BB:CC:00:00:01", "Linux");
        const srv2 = new Serveur("Srv2", "2.2.2.2", "AA:BB:CC:00:00:02", "Windows");

        // 2. On la remplit au maximum
        rack.ajouterEquipement(srv1);

        // 3. V√©rification : L'ajout du 2√®me doit lancer une erreur
        // Note : Avec Jest, pour tester une erreur, on met l'action dans une fonction anonyme () => ...
        expect(() => {
            rack.ajouterEquipement(srv2);
        }).toThrow("est pleine");
    });
});
----

**Action :** Lancez `npm test`.
**R√©sultat attendu :** Le test doit **√©chouer** (ROUGE), car votre classe `Baie` ne g√®re pas encore la capacit√©. C'est normal !

== √âvolution du Mod√®le : La Baie Intelligente

Nous allons maintenant modifier la classe existante pour faire passer le test au VERT.

=== Exercice 2 : Mise √† jour de Baie.js
Modifiez le fichier `src/Baie.js` cr√©√© en S√©ance 1.

**Cahier des charges :**
.   Ajouter une propri√©t√© priv√©e pour stocker la capacit√© maximale.
.   Le constructeur doit accepter un argument `capaciteMax` (avec une valeur par d√©faut de 42).
.   La m√©thode `ajouterEquipement` doit v√©rifier s'il reste de la place **avant** d'ajouter.
.   Si la baie est pleine, elle doit lever une exception : `throw new Error("Message...");`.

[source,javascript]
----
export class Baie {
    // TODO : D√©clarer la propri√©t√© priv√©e capacit√©

    constructor(nom, capaciteMax = 42) {
        this.nom = nom;
        // TODO : Initialiser la capacit√© et le tableau vide
    }

    ajouterEquipement(equipement) {
        // TODO :
        // 1. V√©rifier si la baie est pleine (utiliser estPleine())
        // 2. Si pleine -> throw new Error(...)
        // 3. Sinon -> ajouter au tableau
    }

    estPleine() {
        // TODO : Retourner true si le nombre d'√©quipements atteint la capacit√© max
        return false; // Code temporaire pour ne pas planter
    }

    // ... gardez vos m√©thodes toutAllumer() et listerContenu() existantes ...
}
----

**Action :** Lancez `npm test`. Le test doit d√©sormais **r√©ussir** (VERT).

== L'API : Gestion des Baies (Routes Imbriqu√©es)

Nous allons exposer cette logique via HTTP.

=== Mise √† jour du "store" (app.js)
Dans `app.js`, nous allons changer notre mode de stockage. Au lieu d'un simple tableau d'√©quipements, nous allons g√©rer des Baies.

**Consigne :** Remplacez le tableau `parcInformatique` existant par ceci :

[source,javascript]
----
import { Baie } from './src/Baie.js';
import { Serveur } from './src/Serveur.js';
import { Validator } from './src/Validator.js';

// Ce tableau contiendra d√©sormais des objets de type Baie
const dataCenter = [];

// On initialise avec une baie par d√©faut pour faciliter les tests manuels
dataCenter.push(new Baie("Rack-Principal", 5));
----

=== Exercice 3 : Cr√©er une Baie (POST)
Ajoutez la route `POST /api/baies` dans `app.js`.

**Sp√©cifications :**

* **URL :** `/api/baies`
* **Body JSON attendu :** `{ "nom": "Rack A", "capacite": 10 }`
* **Comportement :** Cr√©er une instance de `Baie` et l'ajouter au tableau `dataCenter`.
* **Contrainte :** Le nom est obligatoire.
* **R√©ponse Succ√®s :** HTTP 201 avec l'ID de la baie.

[source,javascript]
----
app.post('/api/baies', (req, res) => {
    // √Ä VOUS DE JOUER
    // 1. R√©cup√©rer nom et capacit√© du body
    // 2. V√©rifier les donn√©es
    // 3. Instancier la Baie
    // 4. Ajouter au dataCenter
    // 5. Renvoyer la r√©ponse JSON
});
----

=== Exercice 4 : Remplir une Baie (POST imbriqu√©)
Nous voulons ajouter un serveur **DANS** une baie sp√©cifique.
C'est ici que tout se connecte : API + Validation + Logique M√©tier (Capacit√©).

**Sp√©cifications :**

* **URL :** `/api/baies/:index/serveurs`
* **Body JSON attendu :** `{ "hostname": "...", "ip": "...", ... }`
* **Comportement :**
1.  Trouver la baie gr√¢ce √† l'`:index`. Si introuvable -> 404.
2.  Valider les donn√©es du serveur (IP, etc.) via le `Validator`.
3.  Cr√©er l'objet `Serveur`.
4.  L'ajouter √† la baie trouv√©e.
5.  **G√©rer l'erreur "Baie Pleine" :** Si `ajouterEquipement` lance une erreur, renvoyer un code 400.

[source,javascript]
----
app.post('/api/baies/:index/serveurs', (req, res) => {
    try {
        // TODO : Impl√©menter la logique compl√®te
        // Astuce : req.params.index pour trouver la baie

    } catch (e) {
        // TODO : G√©rer les erreurs (400 Bad Request)
        res.status(400).json({ error: e.message });
    }
});
----

=== Exercice 5 : Voir le contenu (GET imbriqu√©)
Cr√©ez la route `GET /api/baies/:index`.

**Sp√©cifications :**

* Elle doit retourner un JSON contenant :
* Le nom de la baie.
* La capacit√© maximale.
* Le nombre d'√©quipements install√©s.
* La liste d√©taill√©e des √©quipements (utilisez `afficherStatut()`).
* **Code HTTP attendu :** 200 (OK) ou 404 (Not Found).

== Bilan du Module

En 3 s√©ances, nous avons construit une application compl√®te :

.   **Mod√®le :** Classes `Serveur`, `Baie` avec H√©ritage et Composition.
.   **Logique :** Tests unitaires avec `Jest` et validation TDD.
.   **API :** Serveur `Express` robuste g√©rant les erreurs et les contraintes m√©tier.