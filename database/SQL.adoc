= Révisions SQL
:author: Amadou Djalo & Amirouche Mamri
:revdate: 2026-01-20
:toc: left
:toc-title: Sommaire
:icons: font
:source-highlighter: highlight.js
:sectnums:

== SQL Simple
On fait les exercices du site: https://www.w3resource.com/sql-exercises/soccer-database-exercise/basic-exercises-on-soccer-database.php

=== Numéro 4
From the following table, write a SQL query to find the number of matches that ended with a result

D'après mon prof, d'abord:

. Une table ou plusieurs pour répondre à la demande ?
Ici une seule table car on est dans la partie BASIC Queries et d'après l'énoncé

. Est ce un requête avec agrégat ou pas ?
Oui car on demande un comptage

. Est ce un COUNT() ou une autre statistique (SUM, MIN, MAX ...) ?
Count simple (lignes) car on demande le nombre de matches

. Y a t'il un filtre ?
Oui car on demande les matches qui se terminent avec un résultat donc NON NUL

SELECT COUNT(*)
FROM match_mast
WHERE results <> 'DRAW'

== Numéro 8
From the following table, write a SQL query to count the number of matches ended with a results in-group stage.

SELECT COUNT(*) as nbMatches
FROM match_mast
WHERE results <> 'DRAW' and play_stage = 'G'

Idem exo 4 avec un filtre de plus

== Numero 26
From the following table, write a SQL query to count the number of penalty shots taken by each team. Return country name, number of shots as "Number of Shots"

SELECT s.country_name, COUNT(*) as "Number of Shots"
FROM penalty_shootout as p
INNER JOIN soccer_country as s
ON p.team_id = s.country_id
GROUP BY s.country_name
order by "Number of Shots" DESC

D'abord on constate que l'on a besoin d'une jointure car le nom du pays n'est pas dans la table où il y a les pénaltys. La clef n'a pas le même nom: dans soccer_country, country_id est clef primaire. Dans penalty_shootout elle est clef étrangère sous le nom de team_id.
On veut un regroupement par pays d'où le GROUP BY
On trie juste pour avoir "visuellement" le même rendu que la restitution en exemple

== Synthèse Méthodologique
Pour réussir chaque requête SQL simple, il faut systématiquement valider ces 4 étapes :

. *L'origine des données (FROM)*
* [ ] Une seule table ? -> `FROM table`
* [ ] Plusieurs tables ? -> Prévoir des `JOIN` (Notion suivante)

. *Le type de résultat attendu (SELECT)*
* [ ] Détail des lignes ? -> Sélectionner les colonnes (`col1, col2`)
* [ ] Une statistique ? -> Utiliser une fonction d'agrégat (`COUNT`, `SUM`, `AVG`, etc.)

. *La spécificité de la fonction (Si agrégat)*
* [ ] Compter des occurrences ? -> `COUNT(*)` ou `COUNT(colonne)`
* [ ] Éliminer les doublons ? -> Ajouter `DISTINCT`

. *Le filtrage (WHERE)*
* [ ] Y a-t-il une condition ? -> Clause `WHERE`
* [ ] Attention aux valeurs nulles -> Utiliser `IS NOT NULL` (et non `= NULL`)
* [ ] Attention aux chaînes de caractères -> Toujours entre simples quotes `' '`

[TIP]
====
Relis toujours l'énoncé pour repérer les mots-clés :
"Nombre de..." -> `COUNT`
"Liste des..." -> Pas d'agrégat
"Total de..." -> `SUM`
====

== SQL Jointures

=== Introduction
Revoir les 2 fiches de méthode sur les jointures de Mr Robert.

Exercices par Mr Coco et Tandia sur les bases cinéma et foot de w3school

=== Exercice 5 - UNION
L'énoncé est: From the following tables, write a SQL query to find the name of all reviewers and movies together in a single list.

Ici il faut IDENTIFIER qu'on a besoin d'un UNION et non pas d'une jointure.
Cf 1ère année UNION pour injections.
Cf également étude de cas avec des UNION d'il y a 2 ans.
L'UNION permet de concaténer le résultat de plusieurs requêtes SELECT à condition que le nombre et le type des colonnes soit identique.

[source,sql]
----
SELECT mov_title
FROM movie
UNION
SELECT rev_name
FROM reviewer
----

=== Exercice 6 : Jointure et filtre

From the following table, write a SQL query to find all reviewers who have rated seven or more stars to their rating. Return reviewer name

D' abord on identifie les colonnes à mettre dans le SELECT.
Ensuite les jointures nécessaires (pour le SELECT ou ... le filtre)


[source,sql]
----
select distinct re.rev_name
from reviewer re
inner join rating ra
on re.rev_id = ra.rev_id
where ra.rev_stars >= 7
----

Ici la jointure sur la table rating sert uniquement au filtre


==== Exercice 1 sur soccer
From the following table, write a SQL query to find out where the final match of the EURO cup 2016 was played. Return venue name, city.

Pour celui ci, on a fait pas à pas (donc pas tout à fait comme la méthodo mais plus détaillé)

.Etape1
Récupération des noms des stades

.Etape 2
Récupération des noms des villes associés

.Etape 3
Récupération des matches pour filtrer sur la phase finale
Ici on est dans la pratique: on a cherché la "bonne colonne". En étude de cas il faudra se baser sur le modèle relationnel

[source,sql]
----
select sv.venue_name, sc.city
from soccer_venue as sv
inner join soccer_city as sc
on sv.city_id = sc.city_id
inner join match_mast as mm
on sv.venue_id = mm.venue_id
where mm.play_stage = 'F'
----

Méthodo pour EDC:
Cas où il n'y a pas de statistiques: on s'occupe du SELECT puis des tables et éventuellement jointures et enfin des filtres

== Mini étude de cas
Exercice 4 TP SQL

[source,sql]
----
-- La liste des évaluations (Nom de l'étudiant, Libellé de la matière, Note et Type d'évaluation) pour toutes les notes qui ont été attribuées par l'enseignant avec pour nom "Turing".

SELECT et.nom, m.libelle_cours, ev.note, ev.type_eval
FROM evaluation ev
INNER JOIN etudiant et ON ev.fk_id_etudiant = et.id_etudiant
INNER JOIN enseignant es ON ev.fk_id_enseignant = es.id_enseignant
INNER JOIN matiere m ON ev.fk_id_matiere = m.id_matiere
WHERE es.nom = 'Turing'
----

Exercice 5 Coco: jointure avec agrégat et table association

[source,sql]
----
SELECT COUNT(DISTINCT m.id_matiere) AS nb_matiere
FROM matiere m
inner JOIN enseigner e
ON m.id_matiere = e.fk_id_matiere
INNER JOIN enseignant en
ON en.id_enseignant = e.fk_id_enseignant
WHERE en.nom = 'Lovelace'
----

Exercice 6 Standia: 4 tables avec 3 jointures

[source,sql]
----
SELECT m.libelle_cours, p.semaine, e.nom
FROM planning AS p
INNER JOIN matiere AS m
ON p.fk_id_matiere = m.id_matiere
INNER JOIN enseignant AS e
ON e.id_enseignant = p.fk_id_enseignant
INNER JOIN salle AS s
ON s.id_salle = p.fk_id_salle
WHERE p.semaine = 'S42'
----


